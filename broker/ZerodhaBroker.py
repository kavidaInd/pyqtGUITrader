"""
brokers/ZerodhaBroker.py
========================
Zerodha KiteConnect implementation of BaseBroker.

Prerequisites:
    pip install kiteconnect

Authentication flow:
    1. User visits the login URL generated by get_login_url()
    2. After login, Zerodha redirects to redirect_uri with a `request_token`
    3. Pass the request_token to generate_session() to get the access_token
    4. Save the access_token via BrokerageSetting.save_token()

Symbol format:
    Zerodha uses plain exchange:tradingsymbol, e.g. "NSE:NIFTY24DECFUT"
    For options: "NFO:NIFTY24DEC24500CE"

API docs: https://kite.trade/docs/connect/v3/
"""

import logging
import time
import random
from datetime import datetime, timedelta
from typing import Optional, Dict, List, Any, Callable

import pandas as pd
from requests.exceptions import Timeout, ConnectionError

from broker.BaseBroker import BaseBroker, TokenExpiredError
from db.connector import get_db
from db.crud import tokens

try:
    from kiteconnect import KiteConnect
    KITE_AVAILABLE = True
except ImportError:
    KITE_AVAILABLE = False

logger = logging.getLogger(__name__)

# ── Zerodha order/product constants ─────────────────────────────────────────
KITE_PRODUCT_MIS = "MIS"       # Intraday margin
KITE_PRODUCT_CNC = "CNC"       # Delivery
KITE_PRODUCT_NRML = "NRML"     # Overnight F&O

KITE_ORDER_MARKET = "MARKET"
KITE_ORDER_LIMIT = "LIMIT"
KITE_ORDER_SL = "SL"           # Stop-loss limit
KITE_ORDER_SLM = "SL-M"        # Stop-loss market

KITE_TXN_BUY = "BUY"
KITE_TXN_SELL = "SELL"

# Zerodha interval mapping: our generic interval -> kite interval
KITE_INTERVAL_MAP = {
    "1": "minute",
    "2": "2minute",
    "3": "3minute",
    "5": "5minute",
    "10": "10minute",
    "15": "15minute",
    "30": "30minute",
    "60": "60minute",
    "120": "2hour",       # not standard; use 60minute twice if needed
    "D": "day",
    "day": "day",
}


class ZerodhaBroker(BaseBroker):
    """
    Zerodha KiteConnect broker implementation.

    BrokerageSetting fields used:
        client_id   → Zerodha API key
        secret_key  → Zerodha API secret
        redirect_uri → Redirect URI registered in developer console
    """

    def __init__(self, state, broker_setting=None):
        self._safe_defaults_init()
        try:
            if not KITE_AVAILABLE:
                raise ImportError(
                    "kiteconnect is not installed. Run: pip install kiteconnect"
                )

            self.state = state

            if broker_setting is None:
                raise ValueError("BrokerageSetting must be provided for ZerodhaBroker.")

            self.api_key = getattr(broker_setting, 'client_id', None)
            self.api_secret = getattr(broker_setting, 'secret_key', None)
            self.redirect_uri = getattr(broker_setting, 'redirect_uri', None)

            # Load saved access token
            access_token = self._load_token_from_db()

            # Initialise KiteConnect
            self.kite = KiteConnect(api_key=self.api_key)

            if access_token:
                self.kite.set_access_token(access_token)
                self.state.token = access_token
                logger.info("ZerodhaBroker: access token loaded from DB")
            else:
                logger.warning("ZerodhaBroker: no access token found — please authenticate")

            logger.info("ZerodhaBroker initialized")

        except Exception as e:
            logger.critical(f"[ZerodhaBroker.__init__] {e}", exc_info=True)
            raise

    @property
    def broker_type(self) -> str:
        return "zerodha"

    def _safe_defaults_init(self):
        self.state = None
        self.api_key = None
        self.api_secret = None
        self.redirect_uri = None
        self.kite = None
        self._last_request_time = 0
        self._request_count = 0

    # ── Authentication helpers ────────────────────────────────────────────────

    def get_login_url(self) -> str:
        """Return the URL the user must visit to authenticate."""
        if not self.kite:
            return ""
        return self.kite.login_url()

    def generate_session(self, request_token: str) -> Optional[str]:
        """
        Exchange request_token for access_token.
        Call this once after the user completes the login redirect.

        Returns the access_token string, or None on failure.
        """
        try:
            data = self.kite.generate_session(request_token, api_secret=self.api_secret)
            access_token = data.get("access_token")
            if access_token:
                self.kite.set_access_token(access_token)
                self.state.token = access_token
                # Persist in DB (expires end-of-day for Zerodha)
                expires_at = (datetime.now() + timedelta(hours=8)).isoformat()
                db = get_db()
                tokens.save_token(access_token, "", expires_at=expires_at, db=db)
                logger.info("ZerodhaBroker: session generated and token saved")
                return access_token
            return None
        except Exception as e:
            logger.error(f"[ZerodhaBroker.generate_session] {e}", exc_info=True)
            return None

    def _load_token_from_db(self) -> Optional[str]:
        try:
            db = get_db()
            token_data = tokens.get(db)
            if token_data and token_data.get("access_token"):
                return token_data["access_token"]
            return None
        except Exception as e:
            logger.error(f"[ZerodhaBroker._load_token_from_db] {e}", exc_info=True)
            return None

    # ── Rate limiting ─────────────────────────────────────────────────────────

    def _check_rate_limit(self):
        current_time = time.time()
        time_diff = current_time - self._last_request_time
        if time_diff < 1.0:
            self._request_count += 1
            if self._request_count > self.MAX_REQUESTS_PER_SECOND:
                time.sleep(1.0 - time_diff + 0.1)
                self._request_count = 0
                self._last_request_time = time.time()
        else:
            self._request_count = 1
            self._last_request_time = current_time

    # ── Symbol helpers ────────────────────────────────────────────────────────

    @staticmethod
    def _format_symbol(symbol: str) -> str:
        """
        Ensure symbol has exchange prefix.
        Default exchange is NSE; options/futures should already carry NFO:.
        """
        if not symbol:
            return symbol
        if ":" in symbol:
            return symbol
        return f"NSE:{symbol}"

    @staticmethod
    def _split_symbol(symbol: str):
        """Return (exchange, tradingsymbol) tuple."""
        if ":" in symbol:
            parts = symbol.split(":", 1)
            return parts[0], parts[1]
        return "NSE", symbol

    @staticmethod
    def _to_kite_interval(interval: str) -> str:
        return KITE_INTERVAL_MAP.get(str(interval), "minute")

    @staticmethod
    def _to_kite_side(side: int) -> str:
        return KITE_TXN_BUY if side == BaseBroker.SIDE_BUY else KITE_TXN_SELL

    # ── BaseBroker implementation ─────────────────────────────────────────────

    def get_profile(self) -> Optional[Dict]:
        try:
            if not self.kite:
                return None
            return self._call(self.kite.profile, context="get_profile")
        except TokenExpiredError:
            raise
        except Exception as e:
            logger.error(f"[ZerodhaBroker.get_profile] {e!r}", exc_info=True)
            return None

    def get_balance(self, capital_reserve: float = 0.0) -> float:
        try:
            if not self.kite:
                return 0.0
            margins = self._call(lambda: self.kite.margins(segment="equity"), context="get_balance")
            if margins:
                available = float(margins.get("available", {}).get("live_balance", 0.0))
                if capital_reserve > 0:
                    available = available * (1 - capital_reserve / 100)
                return available
            return 0.0
        except TokenExpiredError:
            raise
        except Exception as e:
            logger.error(f"[ZerodhaBroker.get_balance] {e!r}", exc_info=True)
            return 0.0

    def get_history(self, symbol: str, interval: str = "2", length: int = 400):
        try:
            if not symbol or not self.kite:
                return None
            exchange, tradingsymbol = self._split_symbol(self._format_symbol(symbol))
            # Look up instrument token
            instrument_token = self._get_instrument_token(exchange, tradingsymbol)
            if not instrument_token:
                logger.warning(f"ZerodhaBroker: instrument token not found for {symbol}")
                return None
            to_date = datetime.now()
            from_date = to_date - timedelta(days=4)
            kite_interval = self._to_kite_interval(interval)
            self._check_rate_limit()
            candles = self._call(
                lambda: self.kite.historical_data(
                    instrument_token, from_date, to_date, kite_interval
                ),
                context="get_history"
            )
            if candles:
                df = pd.DataFrame(candles)
                df = df.rename(columns={"date": "time"})
                return df.tail(length)
            return None
        except TokenExpiredError:
            raise
        except Exception as e:
            logger.error(f"[ZerodhaBroker.get_history] {e!r}", exc_info=True)
            return None

    def get_history_for_timeframe(self, symbol: str, interval: str, days: int = 30):
        try:
            if not symbol or not self.kite:
                return None
            exchange, tradingsymbol = self._split_symbol(self._format_symbol(symbol))
            instrument_token = self._get_instrument_token(exchange, tradingsymbol)
            if not instrument_token:
                return None
            fetch_days = max(days, 60) if interval in ["15", "30", "60"] else (
                max(days, 120) if interval in ["120", "240"] else days
            )
            to_date = datetime.now()
            from_date = to_date - timedelta(days=fetch_days)
            kite_interval = self._to_kite_interval(interval)
            self._check_rate_limit()
            candles = self._call(
                lambda: self.kite.historical_data(
                    instrument_token, from_date, to_date, kite_interval
                ),
                context="get_history_for_timeframe"
            )
            if candles:
                df = pd.DataFrame(candles)
                df = df.rename(columns={"date": "time"})
                return df
            return None
        except TokenExpiredError:
            raise
        except Exception as e:
            logger.error(f"[ZerodhaBroker.get_history_for_timeframe] {e!r}", exc_info=True)
            return None

    def get_option_current_price(self, option_name: str) -> Optional[float]:
        quote = self.get_option_quote(option_name)
        if quote:
            return quote.get("ltp")
        return None

    def get_option_quote(self, option_name: str) -> Optional[Dict[str, float]]:
        try:
            if not option_name or not self.kite:
                return None
            formatted = self._format_symbol(option_name)
            self._check_rate_limit()
            quotes = self._call(lambda: self.kite.quote([formatted]), context="get_option_quote")
            if quotes and formatted in quotes:
                q = quotes[formatted]
                depth = q.get("depth", {})
                buy_depth = depth.get("buy", [{}])
                sell_depth = depth.get("sell", [{}])
                return {
                    "ltp": q.get("last_price"),
                    "bid": buy_depth[0].get("price") if buy_depth else None,
                    "ask": sell_depth[0].get("price") if sell_depth else None,
                    "high": q.get("ohlc", {}).get("high"),
                    "low": q.get("ohlc", {}).get("low"),
                    "open": q.get("ohlc", {}).get("open"),
                    "close": q.get("ohlc", {}).get("close"),
                    "volume": q.get("volume"),
                    "oi": q.get("oi"),
                }
            return None
        except TokenExpiredError:
            raise
        except Exception as e:
            logger.error(f"[ZerodhaBroker.get_option_quote] {e!r}", exc_info=True)
            return None

    def get_option_chain_quotes(self, symbols: List[str]) -> Dict[str, Dict[str, float]]:
        try:
            if not symbols or not self.kite:
                return {}
            formatted = [self._format_symbol(s) for s in symbols if s]
            self._check_rate_limit()
            quotes = self._call(lambda: self.kite.quote(formatted), context="get_option_chain_quotes")
            result = {}
            if quotes:
                for sym, q in quotes.items():
                    clean_sym = sym.split(":", 1)[-1]
                    depth = q.get("depth", {})
                    buy_depth = depth.get("buy", [{}])
                    sell_depth = depth.get("sell", [{}])
                    result[clean_sym] = {
                        "ltp": q.get("last_price"),
                        "bid": buy_depth[0].get("price") if buy_depth else None,
                        "ask": sell_depth[0].get("price") if sell_depth else None,
                        "high": q.get("ohlc", {}).get("high"),
                        "low": q.get("ohlc", {}).get("low"),
                        "volume": q.get("volume"),
                        "oi": q.get("oi"),
                    }
            return result
        except TokenExpiredError:
            raise
        except Exception as e:
            logger.error(f"[ZerodhaBroker.get_option_chain_quotes] {e!r}", exc_info=True)
            return {}

    def place_order(self, **kwargs) -> Optional[str]:
        try:
            if not self.kite:
                return None
            symbol = kwargs.get('symbol')
            qty = kwargs.get('qty', 75)
            side = kwargs.get('side', self.SIDE_BUY)
            order_type = kwargs.get('order_type', self.MARKET_ORDER_TYPE)
            product = kwargs.get('product_type', KITE_PRODUCT_MIS)
            limit_price = kwargs.get('limitPrice', 0)
            stop_price = kwargs.get('stopPrice', 0)

            if not symbol or qty <= 0:
                return None

            exchange, tradingsymbol = self._split_symbol(self._format_symbol(symbol))
            kite_order_type = {
                self.MARKET_ORDER_TYPE: KITE_ORDER_MARKET,
                self.LIMIT_ORDER_TYPE: KITE_ORDER_LIMIT,
                self.STOPLOSS_MARKET_ORDER_TYPE: KITE_ORDER_SLM,
            }.get(order_type, KITE_ORDER_MARKET)

            self._check_rate_limit()
            params = dict(
                variety=KiteConnect.VARIETY_REGULAR,
                exchange=exchange,
                tradingsymbol=tradingsymbol,
                transaction_type=self._to_kite_side(side),
                quantity=qty,
                product=product,
                order_type=kite_order_type,
                price=limit_price if order_type == self.LIMIT_ORDER_TYPE else None,
                trigger_price=stop_price if order_type == self.STOPLOSS_MARKET_ORDER_TYPE else None,
                validity=KiteConnect.VALIDITY_DAY,
            )
            # Remove None params
            params = {k: v for k, v in params.items() if v is not None}

            result = self._call(lambda: self.kite.place_order(**params), context="place_order")
            if result:
                order_id = result if isinstance(result, str) else result.get("order_id")
                logger.info(f"ZerodhaBroker: order placed {order_id}")
                return str(order_id)
            return None
        except TokenExpiredError:
            raise
        except Exception as e:
            logger.error(f"[ZerodhaBroker.place_order] {e!r}", exc_info=True)
            return None

    def modify_order(self, **kwargs) -> bool:
        try:
            order_id = kwargs.get('order_id')
            limit_price = kwargs.get('limit_price', 0)
            if not order_id or limit_price <= 0 or not self.kite:
                return False
            self._check_rate_limit()
            result = self._call(
                lambda: self.kite.modify_order(
                    variety=KiteConnect.VARIETY_REGULAR,
                    order_id=order_id,
                    price=limit_price
                ),
                context="modify_order"
            )
            return result is not None
        except TokenExpiredError:
            raise
        except Exception as e:
            logger.error(f"[ZerodhaBroker.modify_order] {e!r}", exc_info=True)
            return False

    def cancel_order(self, **kwargs) -> bool:
        try:
            order_id = kwargs.get('order_id')
            if not order_id or not self.kite:
                return False
            self._check_rate_limit()
            result = self._call(
                lambda: self.kite.cancel_order(
                    variety=KiteConnect.VARIETY_REGULAR,
                    order_id=order_id
                ),
                context="cancel_order"
            )
            return result is not None
        except TokenExpiredError:
            raise
        except Exception as e:
            logger.error(f"[ZerodhaBroker.cancel_order] {e!r}", exc_info=True)
            return False

    def exit_position(self, **kwargs) -> bool:
        """Exit position by placing a market order on the opposite side."""
        try:
            symbol = kwargs.get('symbol')
            qty = kwargs.get('qty', 0)
            current_side = kwargs.get('side', self.SIDE_BUY)
            exit_side = self.SIDE_SELL if current_side == self.SIDE_BUY else self.SIDE_BUY
            if not symbol or qty <= 0:
                return False
            order_id = self.place_order(symbol=symbol, qty=qty, side=exit_side,
                                        order_type=self.MARKET_ORDER_TYPE)
            return order_id is not None
        except TokenExpiredError:
            raise
        except Exception as e:
            logger.error(f"[ZerodhaBroker.exit_position] {e!r}", exc_info=True)
            return False

    def add_stoploss(self, **kwargs) -> bool:
        kwargs['order_type'] = self.STOPLOSS_MARKET_ORDER_TYPE
        kwargs['side'] = kwargs.get('side', self.SIDE_SELL)
        return self.place_order(**kwargs) is not None

    def remove_stoploss(self, **kwargs) -> bool:
        return self.cancel_order(**kwargs)

    def sell_at_current(self, **kwargs) -> bool:
        return self.place_order(order_type=self.MARKET_ORDER_TYPE,
                                side=self.SIDE_SELL, **kwargs) is not None

    def get_positions(self) -> List[Dict[str, Any]]:
        try:
            if not self.kite:
                return []
            result = self._call(self.kite.positions, context="get_positions")
            if result:
                return result.get("net", [])
            return []
        except TokenExpiredError:
            raise
        except Exception as e:
            logger.error(f"[ZerodhaBroker.get_positions] {e!r}", exc_info=True)
            return []

    def get_orderbook(self) -> List[Dict[str, Any]]:
        try:
            if not self.kite:
                return []
            result = self._call(self.kite.orders, context="get_orderbook")
            return result or []
        except TokenExpiredError:
            raise
        except Exception as e:
            logger.error(f"[ZerodhaBroker.get_orderbook] {e!r}", exc_info=True)
            return []

    def get_current_order_status(self, order_id: str) -> Optional[Any]:
        try:
            if not order_id or not self.kite:
                return None
            result = self._call(
                lambda: self.kite.order_history(order_id=order_id),
                context="order_status"
            )
            return result
        except TokenExpiredError:
            raise
        except Exception as e:
            logger.error(f"[ZerodhaBroker.get_current_order_status] {e!r}", exc_info=True)
            return None

    def is_connected(self) -> bool:
        try:
            return self.get_profile() is not None
        except TokenExpiredError:
            return False
        except Exception:
            return False

    def cleanup(self) -> None:
        logger.info("[ZerodhaBroker] cleanup done")

    # ── Instrument token helper ───────────────────────────────────────────────

    def _get_instrument_token(self, exchange: str, tradingsymbol: str) -> Optional[int]:
        """
        Look up Zerodha instrument token for historical data.
        Caches results for the session to avoid repeated API calls.
        """
        try:
            cache_key = f"{exchange}:{tradingsymbol}"
            if not hasattr(self, '_instrument_cache'):
                self._instrument_cache = {}
            if cache_key in self._instrument_cache:
                return self._instrument_cache[cache_key]

            instruments = self._call(
                lambda: self.kite.instruments(exchange=exchange),
                context="get_instruments"
            )
            if instruments:
                for inst in instruments:
                    if inst.get("tradingsymbol") == tradingsymbol:
                        token = inst["instrument_token"]
                        self._instrument_cache[cache_key] = token
                        return token
            return None
        except Exception as e:
            logger.error(f"[ZerodhaBroker._get_instrument_token] {e}", exc_info=True)
            return None

    # ── Internal call wrapper ─────────────────────────────────────────────────

    def _call(self, func: Callable, context: str = "",
              max_retries: int = 3, base_delay: int = 1):
        """Retry wrapper with Zerodha-specific error handling."""
        from kiteconnect.exceptions import (
            TokenException, NetworkException, DataException,
            InputException, GeneralException
        )
        for attempt in range(max_retries):
            try:
                self._check_rate_limit()
                return func()
            except TokenException as e:
                logger.critical(f"[ZerodhaBroker.{context}] Token error: {e}")
                raise TokenExpiredError(str(e))
            except NetworkException as e:
                delay = base_delay * (2 ** attempt) + random.uniform(0.5, 1.5)
                logger.warning(f"[ZerodhaBroker.{context}] Network error, retry {attempt+1}: {e}")
                time.sleep(delay)
            except (DataException, InputException) as e:
                logger.error(f"[ZerodhaBroker.{context}] Data/Input error: {e}")
                return None
            except GeneralException as e:
                delay = base_delay * (2 ** attempt) + random.uniform(0.5, 1.5)
                logger.warning(f"[ZerodhaBroker.{context}] General error, retry {attempt+1}: {e}")
                time.sleep(delay)
            except (Timeout, ConnectionError) as e:
                delay = base_delay * (2 ** attempt) + random.uniform(0.5, 1.5)
                logger.warning(f"[ZerodhaBroker.{context}] Connection error, retry {attempt+1}: {e}")
                time.sleep(delay)
            except Exception as e:
                logger.error(f"[ZerodhaBroker.{context}] Unexpected: {e!r}", exc_info=True)
                return None
        logger.critical(f"[ZerodhaBroker.{context}] Max retries reached.")
        return None

    # ── WebSocket interface ────────────────────────────────────────────────────

    def create_websocket(self, on_tick, on_connect, on_close, on_error) -> Any:
        """
        Create Zerodha KiteTicker.

        KiteTicker receives ticks as a list of dicts (one per subscribed token).
        Symbols must be mapped to integer instrument_tokens for subscription;
        this broker caches the mapping in self._ws_token_map.
        """
        try:
            from kiteconnect import KiteTicker  # type: ignore

            api_key = self.api_key
            access_token = getattr(self.state, "token", None) if self.state else None
            if not api_key or not access_token:
                logger.error("ZerodhaBroker.create_websocket: missing api_key or access_token")
                return None

            ticker = KiteTicker(api_key, access_token)

            # KiteTicker uses attribute-style callback assignment
            ticker.on_ticks   = on_tick      # called with list of tick dicts
            ticker.on_connect = lambda ws, response: on_connect()
            ticker.on_close   = lambda ws, code, reason: on_close(f"{code}: {reason}")
            ticker.on_error   = lambda ws, code, reason: on_error(f"{code}: {reason}")

            # Cache for symbol → instrument_token mapping (populated lazily)
            if not hasattr(self, "_ws_token_map"):
                self._ws_token_map: Dict[str, int] = {}

            logger.info("ZerodhaBroker: KiteTicker object created")
            return ticker
        except ImportError:
            logger.error("ZerodhaBroker: kiteconnect not installed — pip install kiteconnect")
            return None
        except Exception as e:
            logger.error(f"[ZerodhaBroker.create_websocket] {e}", exc_info=True)
            return None

    def ws_connect(self, ws_obj) -> None:
        """
        Start KiteTicker (blocking — SDK blocks in its own thread).
        WebSocketManager must call this inside a daemon thread.
        """
        try:
            if ws_obj is None:
                return
            ws_obj.connect(threaded=True)   # threaded=True → non-blocking
            logger.info("ZerodhaBroker: KiteTicker connect() called (threaded)")
        except Exception as e:
            logger.error(f"[ZerodhaBroker.ws_connect] {e}", exc_info=True)

    def ws_subscribe(self, ws_obj, symbols: List[str]) -> None:
        """
        Subscribe to Zerodha live ticks.

        Translates generic NSE:SYMBOL → instrument_token (int).
        Uses _get_instrument_token() which caches results.
        Subscribes in FULL mode for depth + LTP data.
        """
        try:
            if ws_obj is None or not symbols:
                return
            from kiteconnect import KiteTicker  # type: ignore

            tokens = []
            for sym in symbols:
                exchange, tradingsymbol = self._split_symbol(self._format_symbol(sym))
                token = self._get_instrument_token(exchange, tradingsymbol)
                if token:
                    tokens.append(token)
                    self._ws_token_map[token] = sym  # reverse map for normalize
                else:
                    logger.warning(f"ZerodhaBroker.ws_subscribe: no token for {sym}")

            if not tokens:
                logger.warning("ZerodhaBroker.ws_subscribe: no valid tokens to subscribe")
                return

            ws_obj.subscribe(tokens)
            ws_obj.set_mode(KiteTicker.MODE_FULL, tokens)
            logger.info(f"ZerodhaBroker: subscribed {len(tokens)} tokens")
        except Exception as e:
            logger.error(f"[ZerodhaBroker.ws_subscribe] {e}", exc_info=True)

    def ws_unsubscribe(self, ws_obj, symbols: List[str]) -> None:
        """Unsubscribe from Zerodha ticks."""
        try:
            if ws_obj is None or not symbols:
                return
            tokens = []
            for sym in symbols:
                exchange, tradingsymbol = self._split_symbol(self._format_symbol(sym))
                token = self._get_instrument_token(exchange, tradingsymbol)
                if token:
                    tokens.append(token)
            if tokens:
                ws_obj.unsubscribe(tokens)
                logger.info(f"ZerodhaBroker: unsubscribed {len(tokens)} tokens")
        except Exception as e:
            logger.error(f"[ZerodhaBroker.ws_unsubscribe] {e}", exc_info=True)

    def ws_disconnect(self, ws_obj) -> None:
        """Close KiteTicker."""
        try:
            if ws_obj is None:
                return
            ws_obj.close()
            logger.info("ZerodhaBroker: KiteTicker closed")
        except Exception as e:
            logger.error(f"[ZerodhaBroker.ws_disconnect] {e}", exc_info=True)

    def normalize_tick(self, raw_tick) -> Optional[Dict[str, Any]]:
        """
        Normalize a Zerodha tick.

        KiteTicker delivers ticks as a list; WebSocketManager passes each
        item individually. Each item is a dict with instrument_token as key.

        Zerodha tick fields: instrument_token, last_price, timestamp,
        ohlc, volume, oi, buy/sell depth arrays.
        """
        try:
            # KiteTicker sends a list — handle both list and single dict
            if isinstance(raw_tick, list):
                # If list, normalize first item (WebSocketManager calls per tick)
                if not raw_tick:
                    return None
                raw_tick = raw_tick[0]

            if not isinstance(raw_tick, dict):
                return None

            instrument_token = raw_tick.get("instrument_token")
            ltp = raw_tick.get("last_price")
            if ltp is None:
                return None

            # Resolve symbol from cached token map
            token_map = getattr(self, "_ws_token_map", {})
            symbol = token_map.get(instrument_token, f"TOKEN:{instrument_token}")

            ohlc = raw_tick.get("ohlc", {})
            depth = raw_tick.get("depth", {})
            buys  = depth.get("buy", [{}])
            sells = depth.get("sell", [{}])

            ts = raw_tick.get("timestamp") or raw_tick.get("exchange_timestamp")

            return {
                "symbol":    symbol,
                "ltp":       float(ltp),
                "timestamp": str(ts) if ts else "",
                "bid":       buys[0].get("price")  if buys  else None,
                "ask":       sells[0].get("price") if sells else None,
                "volume":    raw_tick.get("volume"),
                "oi":        raw_tick.get("oi"),
                "open":      ohlc.get("open"),
                "high":      ohlc.get("high"),
                "low":       ohlc.get("low"),
                "close":     ohlc.get("close"),
            }
        except Exception as e:
            logger.error(f"[ZerodhaBroker.normalize_tick] {e}", exc_info=True)
            return None